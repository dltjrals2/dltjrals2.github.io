---
title: "[Network] 스패닝 트리 프로토콜 개념 정리"

categories:
  - Network
tags:
  - [Network, STP]

toc:  true
toc_sticky: true
show_date: true
read_time: false
use_math: false

date: 2021-10-05
last_modified_at: 2021-10-05
sitemap :
  changefreq : daily
  priority : 1.0
---

## 6. 스위치를 켜라!  

### 1. 스위치와 브리지  

스위치와 브리지는 기본적인 동작에서 별반 차이가 없다.  

스패닝 트리 프로토콜(Spanning Tree Protocol)에서는 브리지와 스위치의 차이가 없다.  

### 2. 스패닝 트리로 가는 첫 번째 과문 2가지  

스패닝 트리 알고리즘이란, 스위치나 브리지에서 발생하는 루핑을 막아주기 위한 프로토콜이다.  

즉 스위치나 브리지 구성에서 출발지부터 목적지까지의 경로가 2개 이상 존재할 때 1개의 경로만을 남겨두고 나머지는 모두 끊어두었다가, 사용하던 경로에 문제가 발생하면 그때 끊어두었던 경로를 하나씩 살린다.  

스패닝 트리 프로토콜을 이해하기 위해서는 2가지 개념 이해가 필요하다.  

첫 번째가 브리지 ID(Bridge ID)이고, 두 번째는 Path Cost라는 것이다.  

브르지 ID란, 브리지나 스위치들이 통신할 때 서로를 확인하기 위해 하나씩 가지고 있는 번호다.  

브리지 ID의 형식은 다음과 같다. 브리지 ID는 16비트의 브리지 우선순위와 48비트의 맥 어드레스로 만들어진다. 즉, 맨 앞에 'Bridge Priority'가 오고, 그 뒤에 바로 'MAC Address'가 오는 것이 Bridge ID이다.  

브르지 우선순위는 16비트로 만들어지기 때문에 올 수 있는 수는 0부터 2의 16승 - 1까지가 된다. 따라서 Bridge Priority에 올 수 있는 수는 0 ~ 65535까지가 된다. 그런데 Bridge Priority는 디폴트로 그 중간에 해당하는 값인 32768을 사용한다. 즉, 아무런 구성도 하지 않은 스위치나 브리지에서 Bridge Priority는 32768이다.  

Bridge Priority 뒤에 오는 맥 어드레스는 이미 스위치에 고정되어 있는 값이다. 따라서 자신의 고유 맥 어드레스가 Bridge Priority 뒤에 붙게 된다.  

예를 들어 맥 어드레스가 0260.8c01.1111이고 Bridge Priority가 32768인 경우, 스위치가 브리지 ID는 8080.0260.8c01.1111이 된다.  

이렇게 만들어진 Bridge ID는 스패닝 트리 프로토콜을 수행할 때 아주 중요한 값으로 사용된다.  

Path Cost란, 말 그대로 '길을 가는데 드는 비용' 정도로만 이해하면 된다. 네트워크 분야에서 길이란 바로 장비와 장비가 연결되어 있는 링크를 말하는 것이다. 즉, Path Cost란, 브리지가 얼마나 가까이, 그리고 빠른 링크로 연결되어 있는지를 알아내기 위한 값이다.  

원래 스피닝 트리 프로토콜을 정의하고 있는데 IEEE.802.ID에서는 이 Cost 값을 계산할 때 1,000Mbps를 두 장비 사이의 링크 대역폭으로 나눈 값을 사용했다.  

예를 들어, 두 스위치가 10Mbps로 연결되어 있다고 가정하면 Path Cost는 1,000Mbps를 둘 사이의 링크 대역폭(즉 여기서는 10Mbps)으로 나눈 값이라고 했으니 다음과 같다.  

1000 / 10 = 100, 따라서 Path Cost가 100이 된다.  

예를 하나 더 들어보면, 100Mbps로 연결된 링크라면 Path Cost는 1,000 / 100 = 10, 즉 10이 된다.  

정리하자면 링크 속도가 빠르면 그만큼 빨리 도착할 테니 Path Cost는 적게 든다고 보는 것이다.  

📌**<u>내용 정리</u>**📌  
- Bridge ID = Bridge Priority(16비트) + MAC Address(48비트)로 구성되어 있다.  
- Path Cost는 속도가 빠를 수록 값이 작고, 소수점이 나오는 것을 막기 위해 IEEE에서 아예 정수 값으로 Path Cost의 값을 지정하였다.  

### 3. 스패닝 트리를 잘하려면 3가지만 기억하세요!  

- 첫째, 네트워크당 하나의 루트 브리지(Root Bridge)를 갖는다.  
- 둘째, 루트 브리지가 아닌 나머지 모든 브리즈(Non Root Bridge)는 무조건 하나씩의 루트 포트(Root Port)를 갖는다.  
- 셋째, 세그먼트(Segment)당 하나씩의 데지그네이트 포트(Designated Port)를 갖는다.  

루트 브리지는 한 마디로 대장 브리지이다. 즉, 스패닝 트리 프로토콜을 수행할 때 기준이 되는 브리지(스위치)이다.  

루트 브리지가 아닌 나머지 모든 브리지를 Non Root Bridge라고 하는데, 이 Non Root Bridge당 하나씩의 루트 포트(Root Port)를 가져야 한다. 여기서 루트 포트란, 루트 브리지에 가장 빨리 갈 수 있는 포트를 말한다. 즉, 루트 브리지 쪽에 가장 가까운 포트라고 볼 수 있다. 따라서 나머지 브리지들은 루트 브리지 쪽으로 가장 가까이 있는 루트 포트를 하나씩 지정해 주어야 한다.  

세그먼트란 쉽게 생각해서 브리지 또는 스위치 간에 연결된 링크라고 생각하면 된다. 즉 브리지나 스위치가 서로 연결되어 있을 때 이 세그먼트에서 반드시 한 포트는 Designated Port(지정 포트)로 선출되어야 한다.  

결국 스패닝 트리 프로토콜은 위 3가지 규칙을 적용해서 어느 쪽 링크를 살려두고, 어느 쪽 링크를 끊을지 결정하는 과정이다.  

📌**<u>내용 정리</u>**📌  
- 네트워크당 하나의 루트 브리지를 선정한다. 
- Non Root Bridge당 하나의 루트 포트를 선정한다.  
- 세그먼트당 하나의 데지그네이티드 포트를 선정한다.  
- 루트 포트나 데지그네이티드 포트가 아닌 나머지 목적은 다 막아버린다. 즉, 루트 포트와 데지그네이티드 포트를 뽑는 목적은 어떤 포트를 살릴지 결정하기 위한 것이다.  

### 4. 누가 누가 더 센가? STP에서 힘 겨루기  

스패닝 트리 프로토콜에서 누가 루트 브리지가 될지를 정하고, 누가 루트 포트나 데지그네이티드 포트가 될지 정하는 순서는 아래와 같다.  

- 1단계 : 누가 더 작은 Root BID를 가졌는가?  
- 2단계 : 루트 브리지까지의 Path Cost 값은 누가 더 작은가?  
- 3단계 : 누구의 BID(Sender BID)가 더 낮은가?  
- 4단계 : 누구의 포트 ID가 더 낮은가?  

위 4단계는 나중에 설명을 한다.  

브리지는 스패닝 트리 정보를 자기들끼리 주고받기 위해서 특수한 프레임을 사용하는데, 이를 'BPDU(Bridge Protocol Data Unit)'라고 한다.  

BPDU(Bridge Protocol Data Unit)에는 루트 브리지의 BID인 Root BID, 루트 브리지까지 가는 경로값인 Root Path Cost, 보내는 브리지의 BID인 Sender BID, 그리고 어떤 포트에서 보냈는지를 알게 해주는 Port ID 정보 등이 실려 있다.  

브리지나 스위치가 부팅을 하면 이들은 각각의 포트로 BPDU를 매 2초마다 내보내면서 서로의 스패닝 트리 정보를 주고받게 된다. 즉 브리지는 이 BPDU를 서로 주고받으면서 누가 루트 브리지이고 어떤 포트가 루트 포트가 될지, 그리고 어떤 데지그네이티드 포트가 될지를 결정하게 된다.  

### 5. 스위치에서 대장 브리지(Root Bridge) 뽑기  

루트 브리지(Root Bridge)를 뽑는 조건은 무조건 낮은 BID를 갖는 녀석이 대장이 된다.  

> 스위치 A : 32768.1111.1111.1111
> 스위치 B : 32768.2222.2222.2222  
> 스위치 C : 32768.3333.3333.3333  

우선, 스위치 B와 스위치 C, 이렇게 2대의 스위치가 부팅(여기서 부팅이란, 전원 스위치를 켜서 스위치를 작동하기 시작한 것을 의미한다.)을 시작한다고 가정하자.  

그럼 스위치 B와 스위치 C는 서로 BPDU(Bridge Protocol Data Unit)를 주고받게 된다.  

브리지가 맨 처음 부팅하고 나서 내보내는 BPDU에는 Sender BID 정보는 물론 자기 자신의 BID를 넣게 된다. 루트 브리지의 BID 역시 자기 자신의 BID를 넣게 된다. 왜냐하면 이 브리지는 이제 막 부팅이 끝나 다른 BPDU를 한 번도 받지 못했기 때문에 일단 이 네트워크에는 자기 혼자 있다고 생각한다.  

이렇게 스위치 B와 스위치 C는 루트 브리지 BID를 자기 자신의 BID로 세팅해서 BPDU를 서로 주고 받았다.  

스위치 B가 BPDU를 내보내고 얼마 지나지 않아 스위치 C로부터 BPDU가 도착했다. 열어보니 루트 브리지의 BID가 32768.3333.3333.3333으로 되어 있다. 이것은 스위치 C가 보낸 BPDU이기 때문이다.  

그럼 스위치 B는 자기가 알고 있던 정보, 즉 루트 브리지의 BID가 32768.2222.2222.2222라는 정보와 방금 스위치 C로부터 받은 정보를 비교하게 된다. 이것은 스위치 C가 보낸 BPDU이기 때문이다.  

그러면 낮은 BID가 루트 브리지가 되므로, 루트 브리지의 BID는 32768.2222.2222.2222가 된다. 즉 스위치 B는 방금 스위치 C에서 받은 BPDU를 무시해 버린다.  

스위치 C역시 제일 처음 부팅한 후 자신의 BID를 루트 브리지 BID라고 세팅한 BPDU를 내보내고 얼마 되지 않아 스위치 B로부터 BPDU를 받는다.  

이 BPDU에는 루트 BID가 32768.2222.2222.2222로 되어 있다. 이 값과 자신이 방금 보낸 BPDU에 있는 루트 브리지 ID 32768.3333.3333.3333을 비교해보니 방금 스위치 B로부터 받은 BPDU에 더 좋은 루트 브리지 ID가 있다. 따라서 스위치 C는 자신의 BPDU에 있는 루트 브리지 BID를 스위치 B의 BID로 바꾸어 다른 곳으로 전송하게 된다.  

잠시 후 새로운 스위치 A가 부팅이 되었다.  

부팅을 마친 스위치 A는 자신의 BPDU에 루트 브리지의 BID를 자기 BID인 32768.1111.1111.1111로 실어서 양쪽의 스위치 B와 스위치 C에 보낸다.  

이때 벌써 스위치 B와 스위치 C에서 역시 BPDU가 스위치 A쪽으로 날아오고 있다. 스위치 B와 C쪽에서 보낸 BPDU는 루트 브리지가 32768.2222.2222.2222 값이 들어있다.  

따라서 더 작은 브리지 BID를 가진 스위치 A가 루트 브리지가 된다.  

여기서 중요한 건 브리지나 스위치가 처음 부티해서 루트 브리지를 찾아나가는 과정이다.  

만약 스위치 C를 꼭 루트 브리지로 만들고 싶다면 어떻게 해야 할까? 이를 위해서 Bridge Prioirty 가 있는 것이다. 이 값을 기존 루트 브리지의 Bridge Priority 값보다 작게 만들어 가장 낮은 BID로 만들 수 있다.  

### 6. 졸병 브리지(Non Root Bridge)의 루트 포트 선출하기  

루트 브리지의 선출이 끝나자 바로 스위치들의 루트 포트 선출이 시작되었다.  

루트 포트는 루트 브리지에서 가장 가까이 있는 포트를 말한다. 즉, Path Cost가 가장 적게 드는 포트가 가장 가까이 있다는 것을 말한다.  

- 루트 브리지 : 스위치 A  
- Non Root Bridge : 스위치 B, C  

각 스위치들은 패스트 이더넷(100Mbps)으로 연결되어 있다고 가정하자.  

루트 브리지 A에서 Non Root Bridge B, C까지의 Path Cost는 각각 19이다. 그래서 루트 브리지 A와 스위치 B, C과 연결된 쪽은 루트 포트가 된다.  

### 7. 스패닝 트리의 마지막 단계 데지그네이티드 포트(Designated Port) 뽑기  

데지그네이티드 포트를 뽑아야 스패닝 트리에서 어떤 포트를 풀어주고 어떤 포트를 막을지가 결정되기 때문에 가장 중요한 단계이다.  

루트 브리지까지의 Path Cost, 즉 세그먼트상에서 Root Path Cost를 서로 비교해서 더 작은 Root Path Cost를 가진 포트가 데지그네이티드 포트로 선출된다.  

즉, 루트 브리지의 모든 포트들은 언제나 데지그네이티드 포트로 선정된다.  

만약 서로 연결된 두 포트의 Root Path Cost의 값이 같다면 누가 데지그네이티드 포트가 될까요?  

이럴 경우에는 아래의 과정을 통해서 정해진다.  

- 1단계 : 누가 더 작은 Root BID를 가졌는가?  
- 2단계 : 루트 브리지까지의 Path Cost 값은 누가 더 작은가?  
- 3단계 : 누구의 BID(Sender BID)가 더 낮은가?  
- 4단계 : 누구의 포트 ID가 더 낮은가?  

### 8. 스패닝 트리 프로토콜의 5가지 상태 변화  

스패닝 트리를 만드는 과정은 간단하게 정리하자면 다음과 같다.  

- 루트 브리지 하나를 뽑는다.  
- 루트 브리지를 제외한 나머지 모든 브리지에 대해 루트 포트를 뽑는다.  
- 데지그네이티드 포트를 뽑는다.  
- 나머지 포트는 Non Designated 포트로 지정하면 된다.  

스패닝 트리 포로토콜을 구현해 나가는 과정에서 모든 스위치나 브리지의 포트들은 언제나 5가지 상태로 변한다.  

- Disabled : 이 상태는 포트가 고장나서 사용할 수 없거나 네트워크 관리자가 포트를 일부러 Shut down시켜 놓은 상태이다.  
-- 이때 데이터 전송은 안된다.  
-- 맥 어드레스를 배울 수 없다.  
-- BPDU를 못 주고 받는다.  
- Blocking : 스위치를 맨 처음 켜거나 Disabled되어 있는 포트를 관리자가 다시 살렸을 때 그 포트는 블로킹 상태로 돌아간다. 이 상태에서는 데이터 전송은 되지 않고 오직 BPDU만 주고받을 수 있다.  
-- 데이터 전송은 안된다.  
-- 맥 어드레스를 배울 수 없다.  
-- BPDU를 주고 받는다.  
- Listening : 블로킹 상태에 있던 스위치 포트가 루트 포트나 데지그네이티드 포트로 선정되면 포트는 바로 리스닝 상태로 넘어갑니다. 물론 리스닝 상태에 있던 포트도 네트워크에 새로운 스위치가 접속했거나 브리지나 스위치의 구성값이 바뀌면 루트 포트나 데지그네이티드 포트에서 Non Designated 포트로 상황이 변할 수 있다. 그렇게 되면 다시 블로킹 상태로 돌아간다.  
-- 데이터 전송은 안된다.  
-- 맥 어디르세를 배울 수 없다.  
-- BPDU를 주고 받는다.  
- Learning : 리스닝 상태에 있던 스위치 포트가 포워딩 딜레이 디폴트 시간인 15초동안 그 상태를 유지하면 리스닝 상태는 러닝 상태로 넘어간다. 러닝 상태에서야 비로서 맥 어드레스를 배워 맥 어드레스 테이블을 만들게 된다.  
-- 데이터 전송은 안된다.  
-- 맥 어드레스를 배우기 시작한다.  
-- BPDU를 주고 받는다.  
- Forwarding : 스위치 포트가 러닝 상태에서 다른 상태로 넘어가지 않고 다시 포워딩 딜레이 시간인 15초 동안 그 상태를 계속 유지하면 러닝 상태에서 포워딩 상태로 넘어가게 된ㄷ나. 포워딩 상태가 되어야 스위치 포트는 드디어 데이터 프레임을 주고받을 수 있게 된다. 즉 블로킹 상태에 있던 포트가 리스닝과 러닝을 거쳐 포워딩 상태로 오려면 디폴트 포워딩 딜레이인 15초가 2번 지난 30초가 소요됩니다.  
-- 데이터 전송은 안된다.  
-- 맥 어드레스를 배워 계속 브리지 테이블을 만든다.  
-- BPDU를 주고 받는다.  

### 9. 배운 거 써먹기 - 직접 한번 구성해 보자구요!  


---
**🐢 현재 공부하고 있는 `후니의 쉽게 쓴 CISCO 네트워킹 - 진강훙 저자` 의 책을 학습하며 기록 및 정리를 하기위한 내용들입니다. 🐢**
{: .notice--primary}

감사합니다.😊