---
title: "[Graph] 그래프 이론1"

categories:
  - Algorithm
tags:
  - [Algorithm, Python, Graph, Disjoint Sets]

toc:  true
toc_sticky: true
show_date: true
read_time: false
use_math: true

date: 2021-06-24
last_modified_at: 2021-06-25
sitemap :
  changefreq : daily
  priority : 1.0
---

## 다양한 그래프 알고리즘  

### 그래프에 대한 복습  

그래프란 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조를 의마한다. 알고리즘 문제를 접했을 때, `서로 다른 개체(혹은 객체)가 연결되어 있다`는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올리자. 예를 들어, '여러 개의 도시가 연결되어 있다'와 같은 내용이 등장하면 그래프 알고리즘을 의심해보자.  
더불어, 그래프 자료구조 중에서 트리 자료구조는 다양한 알고리즘에서 사용되므로 꼭 기억하자. `다익스트라 최단 경로 알고리즘`에서는 우선순위 큐가 사용되었는데, 우선순위 큐를 구현하기 위해 최소 힙이나 최대 힙을 이용할 수 있다. 그래프와 트리 자료구조를 비교한 표는 아래와 같다.  

![image](https://user-images.githubusercontent.com/37467408/123204021-3584c580-d4f2-11eb-94fd-f36b8d60ca6b.PNG)  

또한 그래프의 구현 방법은 2가지 방식이 존재한다.  
- 인접 행렬 : 2차원 배열을 사용하는 방식  
- 인접 리스트 : 리스트를 사용하는 방식  

노드의 개수가 V, 간선의 개수가 E인 그래프를 생각해보면, 인접 행렬을 이용하는 방식은 간선 정보를 저장하기 위해 O(V^2)만큼의 메모리 공간이 필요하다. 반면에 인접 리스트를 이용할 때는 간선 개수만큼의 O(E)만큼의 메모리가 필요하다. 또한 인접 행렬은 특정한 노드 A에서 다른 특정한 노드 B로 이어진 간선의 비용을 O(1)의 시간으로 즉시 알 수 있다는 장점이 있으며, 반면에 인접 리스트를 이용할 때는 O(V)만큼이 시간이 소요된다.  
`다익스트라 알고리즘`은 인접 리스트르를 이용하는 방식이다. 노드의 개수가 V개일 때는 V개의 리스트를 만들어서 각 노드와 연결된 모든 간선에 대한 정보를 리스트에 저장 했다.  
`플로이드 워셜 알고리즘`은 인접 행렬을 이용하는 방식이다. 모든 노드에 대하여 다른 노드로 가는 최소 비용을 V^2 크기의 2차원 리스트에 저장한 뒤에 해당 비용을 갱신해서 최단 거리를 계산했다. 이처럼 인접 행렬과 인접 리스트는 다양한 그래프 알고리즘에서 사용되고 있다.  
중요한 점은 어떤 문제를 만나도 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야 한다는 것이다. 예를 들어 최단 경로를 찾아야 하는 문제가 출제되었을 때, 노드의 개수가 적은 경우는 `플로이드 워셜 알고리즘`을 선택할 수 있고, 노드의 개수가 많은 경우는 `다익스트라 알고리즘`을 선택하면 된다.  

### 서로소 집합  

수학에서 서로소 집합(Disjoint Sets)이란 `공통 원소가 없는 두 집합`을 의미한다. 예를 들어 집합 {1, 2}와 집합 {3, 4}는 서로소 관계이다. 반면에 집합 {1, 2}와 집합 {2, 3}은 2라는 원소가 두 집합에 공통적으로 포함되어 있기 때문에 서로고 관계가 아니다.  

![image](https://user-images.githubusercontent.com/37467408/123206462-b6de5700-d4f6-11eb-9281-a183823428a7.PNG)  

서로소 집합 자료구조를 설명하려면 서로소 집합 개념이 필요하다. 서로소 집합 자료구조는 몇몇 그래프 알고리즘에서 매우 중요하게 사용된다.  
서로소 집합 자료구조란 `서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조`이다. 서로소 집합 자료구조는 `union`과 `find` 2개의 연산으로 조작할 수 있다.  
`union(합집합)` 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산이다. `find(찾기)` 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다. 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성된다.  
서로소 집합 자료구조는 `union-find(합치기 찾기)` 자료구조라고 불리기도 한다.  

> 서로소 집합 자료구조  

서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현하는데, 서로소 집합 정보(합집합 연산)가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.  
- 1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.  
- - A와 B의 루트 노드 A', B'를 각각 찾는다.  
- - A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다.)  
- 2. 모든 union(합집합) 연산을 처리할 때까지 1번 과정을 반복한다.  

이것이 트리를 이용해 서로소 집합을 계산하는 알고리즘이다. 또한, 실제로 구현할 때는 A'와 B'중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많다.  
예시를 통해서 과정을 지켜보도록 하자. 전체 집합 {1, 2, 3, 4, 5, 6}이 6개의 원소로 구성되어 있는 상황을 생각해보자. 이때 다음과 같은 4개의 union 연산이 주어져 있다.  
- union 1, 4  
- union 2, 3  
- union 2, 4  
- union 5, 6  
이러한 4개의 union 연산은 가각 '1과 4는 같은 집합', '2와 3은 같은 집합', '5와 6은 같은 집합'이라는 의미를 가지고 있다. 다시 말해 총 4개의 연산이 존재하는 것이다. 이때 4개의 union 연산이 수행된 후에, 전체 원소들이 결과적으로 어떠한 형태의 부분 집합으로 나누어질지 확인해보자.  
이러한 union 연산들은 그래프 형태로 표현될 수도 있다. 각 원소는 그래프에서의 노드로 표현되고, '같은 집합에 속한다'는 정보를 담은 union 연산들은 간선으로 표현된다. 즉, 6개의 노드가 있고 4개의 간선이 존재하는 그래프로 바꾸어서 생각할 수 있다.  
유의할 점은 다음 그래프는 그래프 형태로 시각화할 수 있다는 의미이다. 실제로 각 원소의 집합 정보를 표현하려면 트리 자료구조를 이용한다. 일반적으로 서로소 집합을 그림으로 표현할 때는 번호가 큰 노드가 번호가 작은 노드를 간선으로 가리키도록 트리 자료구조를 이용해 그림을 그리게 된다. 즉, 트리 구조상 번호가 작은 노드가 부모가 되고, 번호가 큰 노드가 자식이 된다.  

![image](https://user-images.githubusercontent.com/37467408/123207830-f6a63e00-d4f8-11eb-9077-85cdafb34bea.PNG)  

전체 원소가 {1, 2, 3, 4}와 {5, 6}이라는 두 집합으로 나누어지는 것을 알 수 있다. 노드 1, 2, 3, 4가 같은 집합에 속하여 노드 5, 6이 같은 집합에 속한다. 이렇게 union 연산을 토대로 그래프를 그리면 '연결성'으로 손쉽게 집합의 형태를 확인할 수 있다. 위 그래프에서는 노드 3에서 노드 1로 간접적으로 연결되어 이동할 수 있기 때문에, 같은 집합에 있는 것으로 이해할 수 있다. 반면에 노드 1과 노드 5는 서로 연결되어 있지 않기 때문에 서로 다른 집합으로 나누어져 있다고 이해할 수 있다.  
따라서, 그래프가 다음 그림처럼 나누어지는 것을 알 수 있다.  

![image](https://user-images.githubusercontent.com/37467408/123216833-eac07900-d504-11eb-948b-7d11a0fccacf.PNG)  

구체적인 알고리즘 동작 과정을 단계별로 알아보자.  

**<u>step 0</u>** 초기 단계에서는 가장 먼저 노드의 개수(V) 크기의 부모 테이블을 초기화한다. 이때 모든 원소가 자기 자신을 부모로 가지도록 설정한다. 현재 원소의 개수가 6이므로, 초기 단계에서는 총 6개의 트리가 존재하는 것과 같다. 부모 테이블은 말 그대로 부모에 대한 정보만을 담고 있다. 다시 말해, 특정한 노드의 부모에 대해서만 저장하고 있다. 실제로 루트를 확인하고자 할 때는 재귀적으로 부모를 거슬러 올라가서 최종적인 루트 노드를 찾아야 한다.  

![image](https://user-images.githubusercontent.com/37467408/123217226-4e4aa680-d505-11eb-847d-c2810ba19528.PNG)  

**<u>step 1</u>** union 1, 4  
첫 번째 union 연산을 확인하면, 1과 4를 합친다. 이때는 노드 1과 노드 4의 루트 노드를 각각 찾으면 된다. 현재 루트 노드는 각각 1과 4이기 때문에 더 큰 번호에 해당하는 루트 노드 4의 부모를 1로 설정한다.  

![image](https://user-images.githubusercontent.com/37467408/123217355-720dec80-d505-11eb-9108-ffada9266a86.PNG)  

**<u>step 2</u>** union 2, 3  
현재 union 연산을 확인하면, 2와 3을 합친다. 따라서 노드 2와 노드 3의 루트 노드를 각각 찾으면 된다. 현재 루트 노드는 각각 2와 3이기 때문에 더 큰 번호에 해당하는 루트 노드 3의 부모를 2로 설정한다.  

![image](https://user-images.githubusercontent.com/37467408/123217547-a5e91200-d505-11eb-8b19-79d1f769b92b.PNG)  

**<u>step 3</u>** union 2, 4  
다시 union 연산을 확인하면, 2와 4를 합친다. 따라서 노드 2와 노드 4의 루트 노드를 각각 찾으면 된다. 현재 루트 노드는 각각 2와 1이기 때문에 더 큰 번호에 해당하는 루트 노드 2의 부모를 1로 설정한다.  

![image](https://user-images.githubusercontent.com/37467408/123217767-e6e12680-d505-11eb-8ba4-9dceb91605c7.PNG)
![image](https://user-images.githubusercontent.com/37467408/123217850-f95b6000-d505-11eb-8d1e-3ab67c3657d6.PNG)  

**<u>step 4</u>** union 5, 6  
마지막 union 연산을 확인하면, 5와 6을 합친다. 따라서 노드 5와 노드 6의 루트 노드를 각각 찾으면 된다. 현재 루트 노드는 각각 5와 6이기 때문에 더 큰 번호에 해당하는 루트 노드 6의 부모를 5로 설정한다.  

![image](https://user-images.githubusercontent.com/37467408/123217971-214ac380-d506-11eb-8dda-60a43b5d572c.PNG)  

이상으로 모든 union 연산을 처리했다. 이 알고리즘에서 유의할 점은 `union 연산을 효과적으로 수행하기 위해 '부모 테이블'을 항상 가지고 있어야 한다는 점이다.` 또한, `루트 노드를 즉시 계산할 수 없고, 부모 테이블을 계속해서 확인하며 거슬러 올라가야 한다.`  
아래 예시로 살펴보자.  
![image](https://user-images.githubusercontent.com/37467408/123218205-666ef580-d506-11eb-9314-477488f20e16.PNG)  
노드 3의 루트를 찾기 위해서는 먼저 부모 노드인 2로 이동한 다음 노드 2의 부모를 또 확인해서 노드 1로 접근해야 한다. 결과적으로 노드 1을 확인했을 때 더 이상 부모 노드가 없기 때문에 노드 1이 최종적인 루트 노드라는 것을 알 수 있다. 다시 말해 `서로소 집합 알고리즘으로 루트를 찾기 위해서는 재귀적으로 부모를 거슬러 올라가야 한다는 점`을 기억하자.  
파이썬 소스코드는 아래와 같다.  

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
  # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
  if parent[x] != x:
    return find_parent(parent, parent[x])
  return x

# 두 원소가 속한 집합을 찾기
def union_parent(parent, a, b):
  a = find_parent(parent, a)
  b = find_parent(parent, b)
  if a < b:
    parent[b] = a
  else:
    parent[b] = a

# 노드의 개수와 간선(union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
  parent[i] = i

# union 연산을 각각 수행
for i in range(e):
  a, b = map(int, input().split())
  union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end = '')
for i in range(1, v + 1):
  print(find_parent(parent, i), end = )

print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end = '')
for i in range(1, v + 1):
  print(parent[i], end = ' ')
```  

**<u>입력 예시</u>**  
6 4  
1 4  
2 3  
2 4  
5 6  

**<u>출력 예시</u>**  
각 원소가 속한 집합: 1 1 1 1 5 5  
부모 테이블: 1 1 2 1 5 5  

이렇게 답을 구할 수는 있지만, find 함수가 비효율적으로 동작한다. 최악의 경우 find 함수가 모든 노드를 다 확인하는 터라 시간 복잡도가 O(V)라는 점이다.  
결과적으로 현재의 알고리즘을 그대로 이용하게 되면 노드의 개수가 V개이고 find 혹은 union 연산의 개수 M개일 때, 전체 시간 복잡도는 O(VM)이 되어 비효율적이다.  
하지만 이러한 find 함수는 `경로 압축(Path Compression)` 기법을 이용하면 최적화가 가능하다. 즉, 시간 복잡도를 개선할 수 있다. 경로 압축은 find 함수를 재귀적으로 호출한 뒤에 부모 테이블값을 갱신하는 기법이다. 기존의 find 함수를 다음과 같이 변경하면 경로 압축 기법의 구현이 완료가 된다.  

```python
def find_parent(parent, x):
  if parent[x] != x:
    parent[x] = find_parent(parent, parent[x])
  return parent[x]
```  

이렇게 함수를 수정하면 각 노드에 대하여 find 함수를 호출한 이후에, 해당 노드의 루트 노드가 바로 부모 노드가 된다. 아까와 동일하게 {1, 2, 3, 4, 5}의 총 5개의 원소가 존재하는 상황에서 4개의 union 연산이 순서대로 (4, 5), (3, 4), (2, 3), (1, 2)와 같이 주어졌다고 가정해보자. 이때 모든 union 함수를 처리한 후 각 원소에 대하여 find 함수를 수행하면 다음과 같이 부모 테이블이 형성된다. 결과적으로 경로 압축 기법을 이용하게 되면 루트 노드에 더욱 빠르게 접근할 수 있다는 점에서 기존의 기본적인 알고리즘과 비교했을 때 시간 복잡도가 개선된다.  

![image](https://user-images.githubusercontent.com/37467408/123345563-4fc1b080-d591-11eb-8d6c-edda7e1c4c97.PNG)  

경로 압축 기법을 사용한 개선된 서로로 집합 알고리즘 코드는 아래와 같다.  

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
  # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
  if parent[x] != x:
    parent[x] = find_parent(parent, parent[x])
  return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
  a = find_parent(parent, a)
  b = find_parent(parent, b)
  if a < b:
    parent[b] = a
  else:
    parent[a] = b

# 노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# union 연산을 각각 수행
for i in range(e):
  a, b = map(int, input().split())
  union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end = '')
for i in range(1, v + 1):
  print(find_parent(parent, i), end = ' ')

print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end = '')
for i in range(1, v + 1):
  print(parent[i], end = ' ')
```  

> 서로소 집합 알고리즘의 시간 복잡도  

경로 압축 방법을 이용했을 경우, 노드의 개수가 V이고, 최대 V - 1개의 union 연산과 M개의 find 연산이 가능할 때 경로 압축 방법을 적용한 시간 복잡도는 O(V + M(1 + logM/V V))라는 것이 알려져 있다.  

> 서로소 집합을 활용한 사이클 판별  

서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징이 있다. 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있다.  
union 연산은 그래프에서의 간선으로 표현할 수 있다. 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다. 알고리즘은 다음과 같다.  

1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.  
- 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.  
- 루트 노드가 서로 같다면 사이클이 발생한 것이다.  
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.  

다음 그래프의 사이클을 판별하는 과정을 살펴보자.  

**<u>step 0</u>** 초기 단계에서는 모든 노드에 대하여 자기 자신을 부모로 설정하는 형태로 부모 테이블을 초기화한다.  

![image](https://user-images.githubusercontent.com/37467408/123349875-c90ed280-d594-11eb-8888-a355a9184cdf.PNG)  

**<u>step 1</u>** 가장 먼저 간선 (1, 2)를 확인한다. 노드 1과 노드 2의 루트 노드는 각각 1과 2이다. 따라서 더 큰 번호를 갖는 노드 2의 부모 노드를 1로 변경한다.  

![image](https://user-images.githubusercontent.com/37467408/123349931-e5ab0a80-d594-11eb-955b-742119c85413.PNG)  

**<u>step 2</u>** 이어서 간선 (1, 3)을 확인한다. 노드 1과 노드 3의 루트 노드는 각각 1과 3이다. 따라서 더 큰 번호를 갖는 노드 3의 부모 노드를 1로 변경한다.  

![image](https://user-images.githubusercontent.com/37467408/123349967-feb3bb80-d594-11eb-956e-7cd1435341b8.PNG)  

**<u>step 3</u>** 이후에 (2, 3) 간선을 확인한다. 이때 노드 2와 노드 3이 이미 루트 노드로 '노드 1'을 가지고 있다. 다시 말해서 사이클이 발생한다는 것을 알 수 있다.  

![image](https://user-images.githubusercontent.com/37467408/123350044-299e0f80-d595-11eb-9e8b-78317994db91.PNG)  

이러한 사이클 판별 알고리즘은 그래프에 포함되어 있는 간선의 개수가 E개일 때 모든 간선을 하나씩 확인하며, 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 동작한다. 이 알고리즘은 간선에 방향성이 없는 무향 그래프에서만 적용 가능하다.  
아래는 서로소 집합을 활용한 사이클 판별 소스코드이다.  

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
  # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
  if parent[x] != x:
    parent[x] = find_parent(parent, parent[x])
  return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
  a = find_parent(parent, a)
  b = find_parent(parent, b)
  if a < b:
    parent[b] = a
  else:
    parent[a] = b

# 노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
  parent[i] = i

cycle = False # 사이클 발생 여부

for i in range(e):
  a, b = map(int, input().split())
  # 사이클이 발생한 경우 종료
  if find_parent(parent, a) == find(parent, b):
    cycle = True
    break
  #사이클이 발생하지 않았다면 합집합(union) 수행
  else:
    union_parent(parent, a, b)

if cycle:
  print("사이클이 발생했습니다.")
else:
  print("사이클이 발생하지 않았습니다.")
```  

**<u>입력 예시</u>**  
3 3  
1 2  
1 3  
2 3  

**<u>출력 예시</u>**  
사이클이 발생했습니다.  

---
**🐢 현재 공부하고 있는 `이것이 취업을 위한 코딩 테스트다 with 파이썬 - 나동빈 저자` 의 책을 학습하며 기록 및 정리를 하기위한 내용들입니다. 🐢**
{: .notice--primary}

감사합니다.😊
