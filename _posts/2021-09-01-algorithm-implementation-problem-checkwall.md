---
title: "[Implementation] 외벽 점검"

categories:
  - Algorithm
tags:
  - [Algorithm, Python, Implementation, 풀이실패]

toc:  true
toc_sticky: true
show_date: true
read_time: false
use_math: true

date: 2021-09-01
last_modified_at: 2021-09-07
sitemap :
  changefreq : daily
  priority : 1.0
---

## 외벽 점검  

난이도 : ⭐⭐⭐  
푼횟수 : 🔴⚪⚪  

레스토랑을 운영하고 있는 "스카피"는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.  
레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.  
외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.  

**<u>제한 사항</u>**  
- n은 1 이상 200 이하인 자연수입니다.  
- weak의 길이는 1 이상 15 이하입니다.  
  - 서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.  
  - 취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.  
  - weak의 원소는 0 이상 n - 1 이하인 정수입니다.  
- dist의 길이는 1 이상 8 이하입니다.  
  - dist의 원소는 1 이상 100 이하인 자연수입니다.  
- 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.  

**<u>입출력 예</u>**  
n	  weak	             dist	         result  
12	[1, 5, 6, 10]	     [1, 2, 3, 4]	 2  
12	[1, 3, 4, 9, 10]	 [3, 5, 7]	   1  

**<u>입출력 예에 대한 설명</u>**  
입출력 예 1  
원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.  
![image](https://user-images.githubusercontent.com/37467408/131635861-7c3a046c-bbf0-4628-8ea5-01229e99a205.PNG)  
친구들을 투입하는 예시 중 하나는 다음과 같습니다.  

- 4m를 이동할 수 있는 친구는 10m 지점에서 출발해 시계방향으로 돌아 1m 위치에 있는 취약 지점에서 외벽 점검을 마칩니다.  
- 2m를 이동할 수 있는 친구는 4.5m 지점에서 출발해 6.5m 지점에서 외벽 점검을 마칩니다.  
그 외에 여러 방법들이 있지만, 두 명보다 적은 친구를 투입하는 방법은 없습니다. 따라서 친구를 최소 두 명 투입해야 합니다.  

입출력 예 2  
원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.  
![image](https://user-images.githubusercontent.com/37467408/131636019-80fbb8f5-3f64-41b3-97f7-727893e22138.PNG)  
7m를 이동할 수 있는 친구가 4m 지점에서 출발해 반시계 방향으로 점검을 돌면 모든 취약 지점을 점검할 수 있습니다. 따라서 친구를 최소 한 명 투입하면 됩니다.  

> 나의 풀이  

> 문제 해설  

'제한 조건'을 보았을 때, weak 리스트와 dist 리스트의 길이가 매우 작은 것을 알 수 있다. 주어지는 데이터의 개수가 적을 때는 모든 경우를 일일히 확인하는 완전 탐색으로 접근해볼 수 있다.  
문제에서 찾고자 하는 값은 '투입해야 하는 친구 수의 최솟값'이다. 이때 전체 친구의 수(dist의 길이)는 최대 8이다. 따라서 모든 친구를 무작위로 나열하는 모든 순열의 개수를 계산해보면, {}_8 \mathrm{ P }_8 = 8! = 40,320으로 충분히 계산 가능한 경우의 수가 된다. 따라서 친구를 나열하는 모든 경우의 수를 각각 확인하여 친구를 최소 몇 명 배치하면 되는지 계산하면 문제를 해결할 수 있다.  
이처럼 원형으로 나열된 데이터를 처리하는 경우에는, 문제 풀이를 간단히 하기 위하여 길이를 2배로 늘려서 '원형'을 일자 형태로 만드는 작업을 해주면 유리하다.  
문제에서 제시된 입출력 예시 2를 확인해보자. 3명의 친구가 있고, 각각 이동할 수 있는 거리가 3m, 5m, 7m이다. 또한 취약한 지점은 1, 3, 4, 9, 10이라고 한다.  
그러면 먼저 취약한 지점을 2번 나열해서 '원형'을 일자 형태로 만든다. 그러면 다음과 같다.  

- 취약한 지점 : 1, 3, 4, 9, 10, 13, 15, 16, 21, 22  

이제 각 친구를 나열하는 모든 경우의 수는 3! = 6가지이다.  

- [3m, 5m, 7m]  
- [3m, 7m, 5m]  
- [5m, 3m, 7m]  
- [5m, 7m, 3m]  
- [7m, 3m, 5m]  
- [7m, 5m, 3m]  

위 각각의 경우에 대하여 4개의 취약한 지점을 모두 검사할 수 있는지 확인하면 된다. 예를 들어 친구를 나열하는 경우의 수 중에서 [7m, 3m, 5m]를 확인해보자. 이때 7m를 이동할 수 있는 친구가 다음처럼 9m 지점에서 출발하여 5곳을 방문한다면 7m 이동해도 모든 취약 지점을 점검할 수 있다.  

- 취약한 지점 : 1, 3, 4, `9, 10, 13, 15, 16`, 21, 22  

이러한 완전 탐색 아이디어를 소스코드로 옮기면 문제 답안과 같이 된다.  

> 문제 답안  

```python
from itertools import permutations

def solution(n, weak, dist):
    # 길이를 2배로 늘려서 '원형'을 일자 형태로 변형
    length = len(weak)
    for i in range(length):
        weak.append(weak[i] + n)
    answer = len(dist) + 1 # 투입할 친구 수의 최솟값을 찾아야 하므로 len(dist) + 1로 초기화
    # 0부터 length - 1까지의 위치를 각각 시작점으로 설정
    for start in range(length):
        # 친구를 나열하는 모든 경우의 수 각각에 대하여 확인
        for friends in list(permutations(dist, len(dist))):
            count = 1 # 투입할 친구의 수
            # 해당 친구가 점검할 수 있는 마지막 위치
            position = weak[start] + friends[count - 1]
            # 시작점부터 모든 취약 지점을 확인
            for index in range(start, start + length):
                # 점검할 수 있는 위치를 벗어나는 경우
                if position < weak[index]:
                    count += 1 # 새로운 친구를 투입
                    if count > len(dist): # 더 투입이 불가능하다면 종료
                        break
                    position = weak[index] + friends[count - 1]
            answer = min(answer, count) # 최솟값 계산
    if answer > len(dist):
        return -1
    return answer
```

<br>
기출 : 2020 카카오 신입 공채 1차  
링크 : <https://programmers.co.kr/learn/courses/30/lessons/60062>  

---
**🐢 현재 공부하고 있는 `이것이 취업을 위한 코딩 테스트다 with 파이썬 - 나동빈 저자` 의 책을 학습하며 기록 및 정리를 하기위한 내용들입니다. 🐢**
{: .notice--primary}

감사합니다.😊
