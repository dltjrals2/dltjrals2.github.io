---
title: "[Network] RIP, Distance-Vector, IGRP, OSPF 개념 정리"

categories:
  - Network
tags:
  - [Network, RIP, Distance ventor, IGRP]

toc:  true
toc_sticky: true

date: 2021-10-10
last_modified_at: 2021-10-10
---

## 8. 라우팅 프로토콜과의 한판  

### 1. RIP라는 라우팅 프로토콜에 대한 이야기  

다이나믹 라우팅 프로토콜은 운영자가 일일이 경로를 지정하지 않아도 똑똑하게 알아서 길을 찾아가는 프로토콜이다.  

다이나믹 라우팅 프로토콜 중에서 가장 구성이 쉬우면서 가장 단순한 라우팅 프로토콜인 RIP에 대해서 알아보자.  

RIP(Routing Information Protocol)를 간단하게 정리해보자.  

> 라우팅 프로토콜(Routing Protocol)이냐, 라우티드 프로토콜이냐(Routed Protocol)이냐?  

정답은 라우팅 프로토콜이 맞다.  

> 다이나믹 라우팅 프로토콜이냐, 스태틱 라우팅 프로토콜이냐?  

정답은 다아니막 프로토콜이다.  

> 내부용 라우팅 프로토콜(Interior Gateway Protocol)이냐, 외부용 라우팅 프로토콜(Exterior Gateway Protocol)이냐?  

정답은 내부용 라우팅 프로토콜(IGP)이다.  

> 디스턴드 벡트(Distance Vector) 라우팅 프로토콜이냐, 링크 스테이트(Link State) 알고리즘이냐?  

정답은 디스턴드 벡터 알고리즘이다.  

> RIP 라우팅 프로토콜에서 라우터가 좋은 길을 결정하는 기준이 되는 요소는 무엇인가?  

정답은 홉(Hop) 카운트이다.  

> RIP 라우팅 프로토콜에서 최대한 갈 수 있는 홈 카운트의 거리는 어디까지인가?  

정답은 15개까지이다. 16개부터는 도착이 불가능하다.  

> RIP의 디폴트 라우팅 업데이트 주기는?  

정답은 30초이다.  

RIP는 단순하지만 스탠다드, 즉 표준 라우팅 프로토콜이다. 또 라우터의 메모리를 적게 사용하는 장점도 있다.  

RIP의 경우는 최적의 경로를 찾는 방법이 가장 단순하다. 즉 라우터를 몇 번 거쳐서 목적지에 도착하는가를 보는 것이다. 다시 말하면 목적지까지 가는 데 네트워크를 몇 번 거쳐야 하는가이다.  

이것은 홉 카운트(Hop Count)라고 하는데 RIP는 가장 낮은 홉 카운트가 가장 좋은 경로라고 결정하게 된다.  

RIP의 단점은 경로 선택을 오로지 홉 카운트에 의존하기 때문에 속도나 회선의 신뢰도, 그리고 회선의 로드 등을 확인해 볼 수 없다.  

따라서 그냥 라우터를 적게 거치는 것을 좋은 경로로 선택해 버린다.  

RIP의 경우 자신의 라우터에서 15개 이상의 라우터를 거치는 목적지의 경우 Unreachable로 정의하고 데이터를 보내지 못하기 때문에 커다란 네트워크상에서 사용하기는 무리가 있다.  

그럼에도 불구하고 아직도 많은 곳에서 RIP를 사용하는 이유는 소규모 네트워크 상에는 효율성이 좋고, 라우터의 메모리를 적게 차지하며, 게다가 구성이 간편하기 때문이다.  

그리고 모든 라우터에서 지원하는 표준 라우팅 프로토콜이라는 것도 한 가지 이유가 될 것이다.  

만약 어떤 목적지로 가는 경로가 4개 있는데 모두 같은 홉 카운트를 가지고 있는 경우 라우터는 이 네 곳으로 패킷을 분산해서 보낸다. 이것을 <u>로드 밸런싱</u>이라고 한다.  

📌**<u>내용 정리</u>**📌  
- 다이나믹 프로토콜 중의 하나인 RIP는 구성이 간편하고 표준 라우팅 프로토콜이어서 많은 곳에서 사용되고 있다.  
- 경로 선택을 오직 홉 카운트로만 한다든지, 데이터를 최대 라우팅할 수 있는 거리가 짧다는 단점에서 커다란 네트워크보다는 소규모 네트워크에서 많이 사용된다.  
- RIP의 경우는 매 30초마다 이웃한 라우터들과 라우팅 정보를 교환한다. 경로에 이상이 있는 건 아닌지 또 뭔가 새로 생긴 경로가 없는지를 확인한다.  

### 2. RIP와 함께 춤을  

### 3. Distance-Vector 라우팅 알고리즘에서의 문제점과 해결책  

Distance Vector의 문제점이라면 가장 먼저 떠오르는 것이 바로 <u>시간</u>이다. 즉 한 번 배운 라우팅 테이블을 계속 전달하기 때문에 업데이트가 모든 네트워크에 전달되는 시간(이것을 보통 컨버전스 타임이라고 한다.)이 많이 걸리다는 것입니다. 따라서 이것 때문에 흔히 이야기하는 루핑이 발생한다.  

이를 방지하기 위해 해결책은 첫 번째로 <u>Maximum Hop Count</u>를 이용한 방법이다.  

RIP 라우팅 프로토콜의 경우는 최대 홉 카운트를 15로 규정하고 15를 넘어가는 라우팅 경로에 대해서는 Unreachable로 간주한다. 그리고 flush time이 지난 후에는 라우팅 테이블에서 아예 삭제해 버린다.  

이렇게 최대 홉 카운트를 정해놓으면 라우팅의 루핑이 발생하더라도 16까지 이르게 되면 멈출 수 있다.  

그러나 RIP의 최대 홉 카운트 제한은 15홉을 넘어서는 경로에 대해서는 아예 도달할 수 없기 때문에 요즘처럼 네트워크의 규모가 커질 경우 치명적인 약점을 드러내게 된다.  

두 번째로, <u>Hold Down Timer</u>를 이용한 루핑 방지법이다.  

Hold DOWN 타이머가 동작하고 있는 동안에는 외부에서 해당 네트워크에 대한 라우팅 경로 정보를 받았을 때 원래 가지고 있던 메트릭 값(목적지까지의 거리에 대한 값으로, RIP의 경우는 Hop 카운트가 된다.)보다 큰 값이 들어오면 무조건 무시한다.  

그리고 Hold Down 카운터가 종료되거나 목적지에 대한 새로운 경로가 지금 가지고 있던 메트릭과 같거나 좋은 경로가 들어올 때만 이웃 라우터로부터의 업데이트를 받아들인다.  

한 마디로 Hold Down 타이머는 어떤 경로가 죽었다고 판단하면 이 경로에 대한 상태를 바로 바꾸지 않고 일정 시간이 지난 다음에 바꾸겠다는 것이다.  

이 일정 시간은 바로 모든 라우터들이 그 경로가 죽었다는 것을 인식하는 정도라고 생각하면 된다.  

세 번째로 <u>스플릿 호라이즌(Split Horizon)</u>이다.  

스플릿 호라이즌은 한마디로 말하면 라우팅 정보가 들어온 곳으로는 같은 정보를 내보낼 수 없다는 것이다.  

스플릿 호라이즌이 뜻하는 바는 만약 하나의 라우터가 어느 네트워크 정보를 인접한 라우터에서 받았다면, 그 인접한 라우터가 그 네트워크에 더 가까이 있을 것이 분명하며, 이러한 정보를 다른 라우터들로부터 더 이상 받을 필요가 없다.  

또한, 스플릿 호라이즌은 두 라우터 간의 루핑만을 막기 위해서 만들어진 기술이다. 따라서 전체 라우터 네트워크의 루핑을 스플릿 호라이즌을 가지고 막는 것은 어렵다.  

네 번째로, <u>라우팅 포이즈닝(Routing Posioning)</u>이다.  

여기서 포이즈닝이란, 라우팅 테이블에 극약 처방을 한다는 것이다.  

네트워크가 다운이 되면 라우터가 다운된 네트워크에 대한 메트릭 값을 16으로 변경한다. 즉, 사용할 수 없는 값으로 만들어버린다. 그 대신 라우팅 테이블에서 지워버리지는 않는다.  

이런 식으로 다운된 네트워크를 먼저 무한대치로 바꾸어 버리는 방식이 바로 라우트 포이즈닝 방식이다.  

이렇게 되면 라우팅 테이블에서 지워버렸다가 잘못된 라우팅 정보를 받는 일은 미리 막을 수 있는 효과가 있다.  

다섯 번째로, <u>포이즌 리버스</u>방식이다.  

보이즌 리버스는 스플릿 호라이즌을 약간 변형했다고 생각하면 된다.  

스플릿 호라이즌처럼 라우팅 정보를 보내온 쪽으로 알려주지 않는 것이 아니라 라우팅 정보를 되돌려 보내기는 하되 이 값을 무한대 값으로 쓰는 방식이다.  

홉 개수가 무한대라는 뜻은 경로를 사용할 수 없다는 것이라서 라우터는 이 경로에 대한 라우팅 업데이트를 무시하는 것이 된다.  

따라서 경로의 정보를 아주 없애는 것보다 무한대 홉 값을 포함해서 라우팅 업데이트를 실시한다면 다른 모든 라우터들은 실수로 잘못된 경로 정보를 사용하는 경우를 크게 줄일 수 있다.  

여기서 중요한 점은 스플릿 호라이즌은 보이즌 리버스 기능이 첨가되든지 또는 안 되든지 라우팅 루프를 자기 라우터랑 붙어있는 인접 라우터에서만 방지할 수 있다는 것이다.  

따라서 어느 하나만의 루핑 방지 방법을 사용하는 것이 아니라 여기에 있는 여러 가지 방식을 적절하게 활용하는 것이 중요하다.  

📌**<u>내용 정리</u>**📌  
- 디스턴스 벡터 알고리즘은 쉽고, 간편하고, 또 라우팅 테이블을 적게 사용하는 장점이 있지만, 루핑이 발생하기 쉽다는 단점을 가지고 있다.  
- 루핑 방지법으로, 라우팅 메트릭스를 제한하는 방법이 있다.  
- RIP의 경우 최대 홉 카운트를 15까지로 제한하면서 무한의 루핑을 방지하지만, 커다란 네트워크에서는 거리 제한이 있는 약점이 있다.  
- 한 번 다운된 경로에 대해서는 일정 시간 동안 라우팅 업데이트를 받지 않는 홀드 다운  
- 라우팅 정보를 받은 쪽으로는 같은 라우팅 정보를 보내지 않는 스플릿 호라이즌  
- 스플릿 호라이즌을 응용한 포이즌 리버스가 있다.  

### 4. IRPG 라우팅 프로토콜  

RIP와 같은 디스턴스 벡터 라우팅 프로토콜 중의 하나인 IGRP(Interior Gateway Routing Protocol)에 대해서 알아보자.  

> 라우팅 프로토콜이냐, 라우티드 프로토콜이냐?

정답 : 라우팅 프로토콜  

> 다이나믹 프로토콜이냐, 스태틱 라우팅 프로토콜이냐?  

정답 : 다이나믹 프로토콜  

> 내부용 라우팅 프로토콜이냐, 외부용 라우팅 프로토콜이냐?  

정답 : 내부용 라우팅 프로토콜이다.  

> 디스턴스 벡터 라우팅 프로토콜이냐, 링크 스테이트 알고리즘이냐?  

정답 : 디스턴스 벡터 알고리즘이다.  

> IGRP 라우팅 프로토콜은 모든 라우터에서 전부 사용 가능한 프로토콜이다?  

정답 : 아니다. IGRP 라우팅 프로토콜은 표준 프로토콜이 아니라 시스코에서 만들어낸 프로토콜이다.  

> IGRP 라우팅 프로토콜도 홉 카운트만을 따져서 경로를 결정한다?  

정답 : 아니다. IGRP는 다음 다섯 가지 요인을 가지고 가장 좋은 경로를 선택한다.  

첫 번재, Bandwidth 대역폭이란 뜻으로 속도를 의미한다. 최적의 경로를 찾는 프로토콜들이 참고하기 위한 값이라고 생각하면 된다.  

두 번째, Delay 지연이라는 의미이다. 경로를 통해서 도착할 때까지의 지연되는 시간이란 의미라고 받아들이면 된다.  

세 번째, Reliability 신뢰성을 뜻한다. 케이블이나 전용선 등 전송 매체를 통해 패킷을 보낼때 생기는 에러율을 나타내는 수치이다. 다시 말하자면 목적지까지 제대로 도착한 패킷과 에러가 발생한 패킷의 비율이다.  

네 번째, Load 부하를 의미한다. 즉 출발지와 목적지 경로에 어느 정도의 부하가 걸리고 있는지를 측정한다.  

다섯 번째, MTU. 경로의 최대 전송 유닛의 크기를 말하고, 바이트로 표시된다.  

> IGRP는 얼마 만에 한 번씩 라우팅 테이블 업데이트가 일어날까?  

정답 : IGRP는 90초에 한 번씩 라우팅 테이블의 업데이트가 일어난다.  

IGRP는 RIP처럼 15개의 라우터 이상을 넘어가지 못한다는 제약을 극복하기 위해 최대 홉 카운트 255로 커다란 네트워크 적용에도 문제가 없다.  

RIP나 IGRP의 경우는 VLSM(Variable Length Subnet Mask)을 지원하지 못하는 약점이 있고, 또 IGRP는 시스코 라우터에만 적용된다는 단점이 있다.  


---
**🐢 현재 공부하고 있는 `후니의 쉽게 쓴 CISCO 네트워킹 - 진강훙 저자` 의 책을 학습하며 기록 및 정리를 하기위한 내용들입니다. 🐢**
{: .notice--primary}

감사합니다.😊