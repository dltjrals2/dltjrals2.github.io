---
title: "[Network] RIP, Distance-Vector, IGRP, OSPF 개념 정리"

categories:
  - Network
tags:
  - [Network, RIP, Distance ventor, IGRP]

toc:  true
toc_sticky: true

date: 2021-10-10
last_modified_at: 2021-10-11
---

## 8. 라우팅 프로토콜과의 한판  

### 1. RIP라는 라우팅 프로토콜에 대한 이야기  

다이나믹 라우팅 프로토콜은 운영자가 일일이 경로를 지정하지 않아도 똑똑하게 알아서 길을 찾아가는 프로토콜이다.  

다이나믹 라우팅 프로토콜 중에서 가장 구성이 쉬우면서 가장 단순한 라우팅 프로토콜인 RIP에 대해서 알아보자.  

RIP(Routing Information Protocol)를 간단하게 정리해보자.  

> 라우팅 프로토콜(Routing Protocol)이냐, 라우티드 프로토콜이냐(Routed Protocol)이냐?  

정답은 라우팅 프로토콜이 맞다.  

> 다이나믹 라우팅 프로토콜이냐, 스태틱 라우팅 프로토콜이냐?  

정답은 다아니막 프로토콜이다.  

> 내부용 라우팅 프로토콜(Interior Gateway Protocol)이냐, 외부용 라우팅 프로토콜(Exterior Gateway Protocol)이냐?  

정답은 내부용 라우팅 프로토콜(IGP)이다.  

> 디스턴드 벡트(Distance Vector) 라우팅 프로토콜이냐, 링크 스테이트(Link State) 알고리즘이냐?  

정답은 디스턴드 벡터 알고리즘이다.  

> RIP 라우팅 프로토콜에서 라우터가 좋은 길을 결정하는 기준이 되는 요소는 무엇인가?  

정답은 홉(Hop) 카운트이다.  

> RIP 라우팅 프로토콜에서 최대한 갈 수 있는 홈 카운트의 거리는 어디까지인가?  

정답은 15개까지이다. 16개부터는 도착이 불가능하다.  

> RIP의 디폴트 라우팅 업데이트 주기는?  

정답은 30초이다.  

RIP는 단순하지만 스탠다드, 즉 표준 라우팅 프로토콜이다. 또 라우터의 메모리를 적게 사용하는 장점도 있다.  

RIP의 경우는 최적의 경로를 찾는 방법이 가장 단순하다. 즉 라우터를 몇 번 거쳐서 목적지에 도착하는가를 보는 것이다. 다시 말하면 목적지까지 가는 데 네트워크를 몇 번 거쳐야 하는가이다.  

이것은 홉 카운트(Hop Count)라고 하는데 RIP는 가장 낮은 홉 카운트가 가장 좋은 경로라고 결정하게 된다.  

RIP의 단점은 경로 선택을 오로지 홉 카운트에 의존하기 때문에 속도나 회선의 신뢰도, 그리고 회선의 로드 등을 확인해 볼 수 없다.  

따라서 그냥 라우터를 적게 거치는 것을 좋은 경로로 선택해 버린다.  

RIP의 경우 자신의 라우터에서 15개 이상의 라우터를 거치는 목적지의 경우 Unreachable로 정의하고 데이터를 보내지 못하기 때문에 커다란 네트워크상에서 사용하기는 무리가 있다.  

그럼에도 불구하고 아직도 많은 곳에서 RIP를 사용하는 이유는 소규모 네트워크 상에는 효율성이 좋고, 라우터의 메모리를 적게 차지하며, 게다가 구성이 간편하기 때문이다.  

그리고 모든 라우터에서 지원하는 표준 라우팅 프로토콜이라는 것도 한 가지 이유가 될 것이다.  

만약 어떤 목적지로 가는 경로가 4개 있는데 모두 같은 홉 카운트를 가지고 있는 경우 라우터는 이 네 곳으로 패킷을 분산해서 보낸다. 이것을 <u>로드 밸런싱</u>이라고 한다.  

📌**<u>내용 정리</u>**📌  
- 다이나믹 프로토콜 중의 하나인 RIP는 구성이 간편하고 표준 라우팅 프로토콜이어서 많은 곳에서 사용되고 있다.  
- 경로 선택을 오직 홉 카운트로만 한다든지, 데이터를 최대 라우팅할 수 있는 거리가 짧다는 단점에서 커다란 네트워크보다는 소규모 네트워크에서 많이 사용된다.  
- RIP의 경우는 매 30초마다 이웃한 라우터들과 라우팅 정보를 교환한다. 경로에 이상이 있는 건 아닌지 또 뭔가 새로 생긴 경로가 없는지를 확인한다.  

### 2. RIP와 함께 춤을  

### 3. Distance-Vector 라우팅 알고리즘에서의 문제점과 해결책  

Distance Vector의 문제점이라면 가장 먼저 떠오르는 것이 바로 <u>시간</u>이다. 즉 한 번 배운 라우팅 테이블을 계속 전달하기 때문에 업데이트가 모든 네트워크에 전달되는 시간(이것을 보통 컨버전스 타임이라고 한다.)이 많이 걸리다는 것입니다. 따라서 이것 때문에 흔히 이야기하는 루핑이 발생한다.  

이를 방지하기 위해 해결책은 첫 번째로 <u>Maximum Hop Count</u>를 이용한 방법이다.  

RIP 라우팅 프로토콜의 경우는 최대 홉 카운트를 15로 규정하고 15를 넘어가는 라우팅 경로에 대해서는 Unreachable로 간주한다. 그리고 flush time이 지난 후에는 라우팅 테이블에서 아예 삭제해 버린다.  

이렇게 최대 홉 카운트를 정해놓으면 라우팅의 루핑이 발생하더라도 16까지 이르게 되면 멈출 수 있다.  

그러나 RIP의 최대 홉 카운트 제한은 15홉을 넘어서는 경로에 대해서는 아예 도달할 수 없기 때문에 요즘처럼 네트워크의 규모가 커질 경우 치명적인 약점을 드러내게 된다.  

두 번째로, <u>Hold Down Timer</u>를 이용한 루핑 방지법이다.  

Hold DOWN 타이머가 동작하고 있는 동안에는 외부에서 해당 네트워크에 대한 라우팅 경로 정보를 받았을 때 원래 가지고 있던 메트릭 값(목적지까지의 거리에 대한 값으로, RIP의 경우는 Hop 카운트가 된다.)보다 큰 값이 들어오면 무조건 무시한다.  

그리고 Hold Down 카운터가 종료되거나 목적지에 대한 새로운 경로가 지금 가지고 있던 메트릭과 같거나 좋은 경로가 들어올 때만 이웃 라우터로부터의 업데이트를 받아들인다.  

한 마디로 Hold Down 타이머는 어떤 경로가 죽었다고 판단하면 이 경로에 대한 상태를 바로 바꾸지 않고 일정 시간이 지난 다음에 바꾸겠다는 것이다.  

이 일정 시간은 바로 모든 라우터들이 그 경로가 죽었다는 것을 인식하는 정도라고 생각하면 된다.  

세 번째로 <u>스플릿 호라이즌(Split Horizon)</u>이다.  

스플릿 호라이즌은 한마디로 말하면 라우팅 정보가 들어온 곳으로는 같은 정보를 내보낼 수 없다는 것이다.  

스플릿 호라이즌이 뜻하는 바는 만약 하나의 라우터가 어느 네트워크 정보를 인접한 라우터에서 받았다면, 그 인접한 라우터가 그 네트워크에 더 가까이 있을 것이 분명하며, 이러한 정보를 다른 라우터들로부터 더 이상 받을 필요가 없다.  

또한, 스플릿 호라이즌은 두 라우터 간의 루핑만을 막기 위해서 만들어진 기술이다. 따라서 전체 라우터 네트워크의 루핑을 스플릿 호라이즌을 가지고 막는 것은 어렵다.  

네 번째로, <u>라우팅 포이즈닝(Routing Posioning)</u>이다.  

여기서 포이즈닝이란, 라우팅 테이블에 극약 처방을 한다는 것이다.  

네트워크가 다운이 되면 라우터가 다운된 네트워크에 대한 메트릭 값을 16으로 변경한다. 즉, 사용할 수 없는 값으로 만들어버린다. 그 대신 라우팅 테이블에서 지워버리지는 않는다.  

이런 식으로 다운된 네트워크를 먼저 무한대치로 바꾸어 버리는 방식이 바로 라우트 포이즈닝 방식이다.  

이렇게 되면 라우팅 테이블에서 지워버렸다가 잘못된 라우팅 정보를 받는 일은 미리 막을 수 있는 효과가 있다.  

다섯 번째로, <u>포이즌 리버스</u>방식이다.  

보이즌 리버스는 스플릿 호라이즌을 약간 변형했다고 생각하면 된다.  

스플릿 호라이즌처럼 라우팅 정보를 보내온 쪽으로 알려주지 않는 것이 아니라 라우팅 정보를 되돌려 보내기는 하되 이 값을 무한대 값으로 쓰는 방식이다.  

홉 개수가 무한대라는 뜻은 경로를 사용할 수 없다는 것이라서 라우터는 이 경로에 대한 라우팅 업데이트를 무시하는 것이 된다.  

따라서 경로의 정보를 아주 없애는 것보다 무한대 홉 값을 포함해서 라우팅 업데이트를 실시한다면 다른 모든 라우터들은 실수로 잘못된 경로 정보를 사용하는 경우를 크게 줄일 수 있다.  

여기서 중요한 점은 스플릿 호라이즌은 보이즌 리버스 기능이 첨가되든지 또는 안 되든지 라우팅 루프를 자기 라우터랑 붙어있는 인접 라우터에서만 방지할 수 있다는 것이다.  

따라서 어느 하나만의 루핑 방지 방법을 사용하는 것이 아니라 여기에 있는 여러 가지 방식을 적절하게 활용하는 것이 중요하다.  

📌**<u>내용 정리</u>**📌  
- 디스턴스 벡터 알고리즘은 쉽고, 간편하고, 또 라우팅 테이블을 적게 사용하는 장점이 있지만, 루핑이 발생하기 쉽다는 단점을 가지고 있다.  
- 루핑 방지법으로, 라우팅 메트릭스를 제한하는 방법이 있다.  
- RIP의 경우 최대 홉 카운트를 15까지로 제한하면서 무한의 루핑을 방지하지만, 커다란 네트워크에서는 거리 제한이 있는 약점이 있다.  
- 한 번 다운된 경로에 대해서는 일정 시간 동안 라우팅 업데이트를 받지 않는 홀드 다운  
- 라우팅 정보를 받은 쪽으로는 같은 라우팅 정보를 보내지 않는 스플릿 호라이즌  
- 스플릿 호라이즌을 응용한 포이즌 리버스가 있다.  

### 4. IRPG 라우팅 프로토콜  

RIP와 같은 디스턴스 벡터 라우팅 프로토콜 중의 하나인 IGRP(Interior Gateway Routing Protocol)에 대해서 알아보자.  

> 라우팅 프로토콜이냐, 라우티드 프로토콜이냐?

정답 : 라우팅 프로토콜  

> 다이나믹 프로토콜이냐, 스태틱 라우팅 프로토콜이냐?  

정답 : 다이나믹 프로토콜  

> 내부용 라우팅 프로토콜이냐, 외부용 라우팅 프로토콜이냐?  

정답 : 내부용 라우팅 프로토콜이다.  

> 디스턴스 벡터 라우팅 프로토콜이냐, 링크 스테이트 알고리즘이냐?  

정답 : 디스턴스 벡터 알고리즘이다.  

> IGRP 라우팅 프로토콜은 모든 라우터에서 전부 사용 가능한 프로토콜이다?  

정답 : 아니다. IGRP 라우팅 프로토콜은 표준 프로토콜이 아니라 시스코에서 만들어낸 프로토콜이다.  

> IGRP 라우팅 프로토콜도 홉 카운트만을 따져서 경로를 결정한다?  

정답 : 아니다. IGRP는 다음 다섯 가지 요인을 가지고 가장 좋은 경로를 선택한다.  

첫 번재, Bandwidth 대역폭이란 뜻으로 속도를 의미한다. 최적의 경로를 찾는 프로토콜들이 참고하기 위한 값이라고 생각하면 된다.  

두 번째, Delay 지연이라는 의미이다. 경로를 통해서 도착할 때까지의 지연되는 시간이란 의미라고 받아들이면 된다.  

세 번째, Reliability 신뢰성을 뜻한다. 케이블이나 전용선 등 전송 매체를 통해 패킷을 보낼때 생기는 에러율을 나타내는 수치이다. 다시 말하자면 목적지까지 제대로 도착한 패킷과 에러가 발생한 패킷의 비율이다.  

네 번째, Load 부하를 의미한다. 즉 출발지와 목적지 경로에 어느 정도의 부하가 걸리고 있는지를 측정한다.  

다섯 번째, MTU. 경로의 최대 전송 유닛의 크기를 말하고, 바이트로 표시된다.  

> IGRP는 얼마 만에 한 번씩 라우팅 테이블 업데이트가 일어날까?  

정답 : IGRP는 90초에 한 번씩 라우팅 테이블의 업데이트가 일어난다.  

IGRP는 RIP처럼 15개의 라우터 이상을 넘어가지 못한다는 제약을 극복하기 위해 최대 홉 카운트 255로 커다란 네트워크 적용에도 문제가 없다.  

RIP나 IGRP의 경우는 VLSM(Variable Length Subnet Mask)을 지원하지 못하는 약점이 있고, 또 IGRP는 시스코 라우터에만 적용된다는 단점이 있다.  

### 5. OSPF 라우팅 프로토콜  

우선 Convergence Time이다. 컨버전스 타임은 쉽게 라우터 간에 서로 변경된 정보를 주고받는 데 걸리는 시간이다.  

예를 들어 어떤 인터페이스가 죽었을 때 이 정보가 모든 라우터들 사이에 퍼지는 데 걸리는 시간이 바로 컨버전스 타임이 된다.  

RIP의 경우는 매 30초에 한 번씩 업데이트가 일어나고 홀드다운 타임이니, 에이징이나 하는 것들 때문에 컨버전스에 많은 시간이 걸리지만, OSPF는 어떤 변화가 생길 대 바로 전달할 수 있기 때문에 훨씬 빠르다.  

따라서 큰 네트워크에 아주 적당하다. 특히 OSPF는 Area라는 개념을 사용해서 전체 OSPF 네트워크를 작은 영역으로 나누어 관리하기 때문에 빠른 업데이트를 하면서도 효율적인 관리가 가능하다.  

또 하나는 VLSM을 지원하는가의 여부이다. RIP v1의 경우는 당연히 이것을 지원하지 못한다.  

하지만 OSPF는 VLSM을 확실하게 지원한다. VLSM을 지원하게 되면 IP 주소를 효과적으로 사용할 수 있다는 장점뿐만 아니라 라우팅 테이블을 줄이는 부수적인 효과도 있다.  

이를 위해 OSPF는 라우팅 서머리제이션을 지원하기 때문에 여러 개의 라우팅 경로를 묶어주는 기능이 탁월하다.  

이번에는 네트워크 크기에 대한 제한이다.  

RIP의 경우는 최대 15개의 홉 카운트밖에 넘어가지 못한다. 즉 최대 15대의 라우터만을 건널 수 있기 때문에 이보다 더 멀리 떨어진 곳까지는 데이터의 전달이 불가능하다.  

하지만 OSPF는 이런 제한이 없다.  

또 네트워크 대역폭의 활용 측면에서도 OSPF가 앞선다. RIP의 경우는 매 30초마다 브로드캐스트가 발생하기 때문에 대역폭 낭비가 많지만, OSPF는 네트워크의 변화가 있을 때만 정보가 날아가기 때문에 훨씬 실용적이다.  

마지막으로 경로 결정에 관한 것도 있다.  

RIP는 홉 카운트만을 따지기 때문에 속도나 딜레이와 상관없이 홉 카운트가 적은 것만을 선호하지만 OSPF는 많은 관련 요소를 합쳐서 경로를 선택하기 때문에 훨씬 정확한 경로 선택이 가능하다.  

OSPF는 표준 라우팅 프로콜이고, 링크스테이트 라우팅 알고리즘이다.  

OSPF가 적용되는 네트워크 타입은 토폴로지(Topology)이다.  

일반적으로 다른 라우팅 프로토콜의 경우는 토폴로지를 별로 따지지 않는 데 반해서, OSPF는 토폴로지가 바뀌는 것에 따라 약간씩 동작이 바뀐다.  

첫 번째로, 브로드캐스트 멀티액세스 토폴로지(Broadcast Multi-access Topology)가 있다.  

네트워크에 2개 이상의 라우터가 연결되는 경우로, 하나의 메시지를 내보내면 이 네트워크상에 있는 모든 녀석들이 정보를 받아볼 수 있는 구조이다.  

가장 일반적인 예를 들자면 이더넷 세그먼트가 된다.  

두 번째로, 포인트 투 포인트 토폴로지(Point-to-Point Topology)이다.  

네트워크에 한 쌍의 라우터만 존재하는 경우가 된다. 일반적인 경우가 전용선 같은 것이다.  

마지막은 NBMA(Non Broadcast Multiple Access)라는 토폴로지이다.  

이 토폴로지 역시 네트워크에 2개 이상의 라우터가 연결된다. 하지만 브로드캐스트 멀티엑세스와는 다르게 브로드캐스트 능력은 가지고 있지 않다.  

프레임릴이나 X.25 네트워크가 이 경우에 해당된다.   

OSPF는 종류별로 네트워크를 나누어 지원하고, 동작 방식도 약간씩 다르기 때문에 구성 시 이 네트워크가 어떤 토폴로지인지를 먼저 확인한 다음에 구성에 들어가야 한다.  

> OSPF의 이웃 사랑  

원래 OSPF에서 라우터는 주위에 있는 OSPF 라우터들을 찾아서 자신의 데이터베이스 안에 저장하는데, 이런 주위의 라우터들을 이웃이라고 한다.  

즉 주변에 어떤 이웃들이 사는지에 대한 정보를 관리하는 것이다. 이렇게 이웃을 찾아내기 위해서 OSPF 라우터는 Hello 패킷을 멀티캐스트로 내보내게 된다.  

헬로를 받은 다른 라우터들은 Hello 패킷을 보낸 OSPF 라우터를 자신들의 이웃 목록에 넣게 되는데, 이를 Init 과정이라고 한다.  

Hello 패킷을 받은 OSPF 라우터들이 Hello 패킷을 보낸 라우터에게 유니캐스트로 자신들의 정보를 보내게 된다.  

그러면 Hello 패킷을 보낸 라우터는 유니캐스토로 받은 정보를 자신의 Neighbor 리스트에 넣어 관리하게 된다.  

Hello 패킷 안에는 많은 정보가 들어있다. 라우터 ID, DR, BDR을 결정하기 위한 Priority 필드도 있다.  

Neighbor 관계가 형성되어야 비로소 통신을 시작할 수 있다. 또 이런 이웃 관계 형성을 위해 헬로 패킷이 사용되는데, 이 패킷은 10초에 한 번씩 발생되고, 헬로 패킷에는 이웃이 되기 위해서 꼭 일치해야 하는 정보가 들어있다.  

OSPF에서는 라우터 ID를 이용해서 서로를 식별하기 때문에 굉장히 중요한 의미를 갖는다. OSPF에서 중요한 역할을 하는 Router ID는 통상 그 라우터의 IP 중 가장 높은 IP 주소를 사용한다.  

라우터 ID를 쓰기 위해서 보통 LoopBack 인터페이스를 사용한다. OSPF에서 LoopBack 인터페이스를 사용하면 그 IP의 주소의 높낮이에 관계 없이 무조건 Loopback 주소가 라우터 ID가 된다.  

또 Loopback 인터페이스는 다운되는 인터페이스가 아니기 때문에 라우터 ID가 바뀔 염려도 없다.  

📌**<u>내용 정리</u>**📌  
- OSPF에서는 서로 헬로 패킷을 주고받으며 이웃 라우터와 인사를 하는데, 이때 가장 중요한 하나가 바로 라우터 ID이다.  
- 라우터 ID는 그 라우터의 살아있는 인터페이스 중 가장 높은 IP 주소를 사용하게 되는데, 만약 이 인터페이스의 상태가 불안정해서 자꾸 다운될 경우 ID가 자주 바뀌게 된다.  
- 위의 문제를 방지하기 위해 안정된 인터페이스의 IP 주소를 라우터 IF로 만드는 것이 좋은데, 이를 위해 OSPF에서는 Loopback 인터페이스를 사용한다.  
- Loopback 인터페이스가 있으면 주소의 높낮이에 상관없이 무조건 이 주소가 라우터 ID가 된다.  

> OSPF애서의 반장과 부반장  

OSPF에서 없어서는 안될 DR(Designated Router)과 BDR(Backup Designated Router) 이다.  

OSPF 세그먼트에서는 각 라우터들이 OSPF에 참여하게 되면 DR과 BDR에 자신의 Link State를 알리게 된다.  

이렇게 DR, BDR에만 자신의 링크 정보를 알리는 이유는 모든 라우터들과 Link State를 교환할 경우 발생하는 트래픽을 줄이고 Link State의 Sync를 제대로 관리하기 위해서이다.  

이 정보를 전달받은 DR은 이 정보를 모두 관리하면서 링크의 상태를 항상 일치시키는 역할을 하게 된다.  

BDR은 DR이 업무 수행 능력이 없어지면 자신이 역할을 대신하게 된다.  

따라서 OSPF에서는 모든 라우터가 반드시 DR, BDR, Link State를 일치해야 합니다. 이것은 어드제이션시라고 한다.  

DR과 BDR은 라우터 ID와 라우터의 Priority를 가지고 선출된다.  

> OSPF에서 링크 변화 눈치채기  

> 간단한 OSPF 구성  

---
**🐢 현재 공부하고 있는 `후니의 쉽게 쓴 CISCO 네트워킹 - 진강훙 저자` 의 책을 학습하며 기록 및 정리를 하기위한 내용들입니다. 🐢**
{: .notice--primary}

감사합니다.😊